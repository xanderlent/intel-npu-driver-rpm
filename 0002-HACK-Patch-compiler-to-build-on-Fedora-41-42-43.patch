From 6032c2e244511727f0db2ae3e47e5dadd1fffb01 Mon Sep 17 00:00:00 2001
From: "Alexander F. Lent" <lx@xanderlent.com>
Date: Wed, 9 Jul 2025 21:57:08 -0400
Subject: [PATCH 2/2] HACK: Patch compiler to build on Fedora 41/42/43

---
 compiler/compiler_source.cmake                |   9 +-
 ...K-Fix-build-on-Fedora-42-with-GCC-15.patch |  25 +++
 ...-Fix-errors-with-GCC-14-on-Fedora-41.patch | 164 ++++++++++++++++++
 ...nore-errors-with-GCC-15-on-Fedora-42.patch |  38 ++++
 4 files changed, 235 insertions(+), 1 deletion(-)
 create mode 100644 compiler/patches/0001-HACK-Fix-build-on-Fedora-42-with-GCC-15.patch
 create mode 100644 compiler/patches/0001-HACK-Fix-errors-with-GCC-14-on-Fedora-41.patch
 create mode 100644 compiler/patches/0001-HACK-Ignore-errors-with-GCC-15-on-Fedora-42.patch

diff --git a/compiler/compiler_source.cmake b/compiler/compiler_source.cmake
index 7e707ea..0c10c99 100644
--- a/compiler/compiler_source.cmake
+++ b/compiler/compiler_source.cmake
@@ -91,7 +91,14 @@ ExternalProject_Add(
     git -C ${NPU_COMPILER_SOURCE_DIR} lfs install &&
     git -C ${NPU_COMPILER_SOURCE_DIR} lfs pull &&
     git -C ${NPU_COMPILER_SOURCE_DIR}/thirdparty/vpucostmodel lfs install &&
-    git -C ${NPU_COMPILER_SOURCE_DIR}/thirdparty/vpucostmodel lfs pull
+    git -C ${NPU_COMPILER_SOURCE_DIR}/thirdparty/vpucostmodel lfs pull &&
+    git -C ${NPU_COMPILER_SOURCE_DIR} apply ${CMAKE_CURRENT_SOURCE_DIR}/patches/0001-HACK-Fix-errors-with-GCC-14-on-Fedora-41.patch &&
+    git -C ${NPU_COMPILER_SOURCE_DIR}/thirdparty/vpucostmodel apply ${CMAKE_CURRENT_SOURCE_DIR}/patches/0001-HACK-Ignore-errors-with-GCC-15-on-Fedora-42.patch &&
+    git -C ${NPU_COMPILER_SOURCE_DIR}/thirdparty/llvm-project apply ${CMAKE_CURRENT_SOURCE_DIR}/patches/0001-HACK-Fix-build-on-Fedora-42-with-GCC-15.patch
+  # The above patching hack is inspired by upstream's patch disabling -Werror to make it build on Fedora 41
+  # https://github.com/intel/linux-npu-driver/commit/c79e5bc9f5363a24fb2f55eaa5e1202c13ed5ea2
+  # The difference is that I tried to fix the upstream code instead.
+  # Best practice is to disable -Werror on distro builds, though. Probably have to do that, eventually...
   CONFIGURE_COMMAND ""
   BUILD_COMMAND ""
   INSTALL_COMMAND ""
diff --git a/compiler/patches/0001-HACK-Fix-build-on-Fedora-42-with-GCC-15.patch b/compiler/patches/0001-HACK-Fix-build-on-Fedora-42-with-GCC-15.patch
new file mode 100644
index 0000000..37c8720
--- /dev/null
+++ b/compiler/patches/0001-HACK-Fix-build-on-Fedora-42-with-GCC-15.patch
@@ -0,0 +1,25 @@
+From e4e06d1114c1e67b418c81ed3f213ffc7d5e7243 Mon Sep 17 00:00:00 2001
+From: "Alexander F. Lent" <lx@xanderlent.com>
+Date: Wed, 9 Jul 2025 21:37:26 -0400
+Subject: [PATCH] HACK: Fix build on Fedora 42 with GCC 15
+
+(This patch is to Intel's npu-plugin-llvm repo.)
+---
+ mlir/include/mlir/Dialect/Affine/IR/ValueBoundsOpInterfaceImpl.h | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/mlir/include/mlir/Dialect/Affine/IR/ValueBoundsOpInterfaceImpl.h b/mlir/include/mlir/Dialect/Affine/IR/ValueBoundsOpInterfaceImpl.h
+index 451c466fa0c9..642e99d963ef 100644
+--- a/mlir/include/mlir/Dialect/Affine/IR/ValueBoundsOpInterfaceImpl.h
++++ b/mlir/include/mlir/Dialect/Affine/IR/ValueBoundsOpInterfaceImpl.h
+@@ -10,6 +10,7 @@
+ #define MLIR_DIALECT_AFFINE_IR_VALUEBOUNDSOPINTERFACEIMPL_H
+ 
+ #include "mlir/Support/LLVM.h"
++#include <cstdint>
+ 
+ namespace mlir {
+ class DialectRegistry;
+-- 
+2.50.0
+
diff --git a/compiler/patches/0001-HACK-Fix-errors-with-GCC-14-on-Fedora-41.patch b/compiler/patches/0001-HACK-Fix-errors-with-GCC-14-on-Fedora-41.patch
new file mode 100644
index 0000000..29c8416
--- /dev/null
+++ b/compiler/patches/0001-HACK-Fix-errors-with-GCC-14-on-Fedora-41.patch
@@ -0,0 +1,164 @@
+From 07338eb17405f4a78966708e8a14d3f06f1f53e7 Mon Sep 17 00:00:00 2001
+From: "Alexander F. Lent" <lx@xanderlent.com>
+Date: Wed, 9 Jul 2025 21:35:06 -0400
+Subject: [PATCH] HACK: Fix errors with GCC 14 on Fedora 41
+
+(This patch makes npu_compiler build correctly.)
+---
+ .../conversion/passes/IE2VPU/convert_IE_to_VPU_NCE.hpp      | 2 +-
+ .../IE/transforms/passes/adapt_shapes_for_scale_shift.cpp   | 6 +++---
+ .../dialect/IE/transforms/passes/convert_to_scale_shift.cpp | 2 +-
+ src/vpux_compiler/src/dialect/VPU/utils/nce_sparsity.cpp    | 3 ++-
+ src/vpux_compiler/src/dialect/VPUIP/IR/ops/sw_kernel.cpp    | 6 ++++--
+ src/vpux_compiler/src/dialect/VPUIP/IR/types/iti_buffer.cpp | 3 ++-
+ src/vpux_compiler/src/dialect/VPUIP/utils/sw_utils.cpp      | 3 +++
+ .../src/dialect/const/passes/apply_swizzling.cpp            | 3 ++-
+ 8 files changed, 18 insertions(+), 10 deletions(-)
+
+diff --git a/src/vpux_compiler/include/vpux/compiler/conversion/passes/IE2VPU/convert_IE_to_VPU_NCE.hpp b/src/vpux_compiler/include/vpux/compiler/conversion/passes/IE2VPU/convert_IE_to_VPU_NCE.hpp
+index bb94eec0..7bd5c79c 100644
+--- a/src/vpux_compiler/include/vpux/compiler/conversion/passes/IE2VPU/convert_IE_to_VPU_NCE.hpp
++++ b/src/vpux_compiler/include/vpux/compiler/conversion/passes/IE2VPU/convert_IE_to_VPU_NCE.hpp
+@@ -19,7 +19,7 @@ namespace vpux {
+ template <class ConcreteOp>
+ class EltwiseToNCE final : public mlir::OpRewritePattern<ConcreteOp> {
+ public:
+-    EltwiseToNCE<ConcreteOp>(mlir::MLIRContext* ctx, VPU::EltwiseType opType, Logger log)
++    EltwiseToNCE(mlir::MLIRContext* ctx, VPU::EltwiseType opType, Logger log)
+             : mlir::OpRewritePattern<ConcreteOp>(ctx), _opType(opType), _log(log) {
+     }
+ 
+diff --git a/src/vpux_compiler/src/dialect/IE/transforms/passes/adapt_shapes_for_scale_shift.cpp b/src/vpux_compiler/src/dialect/IE/transforms/passes/adapt_shapes_for_scale_shift.cpp
+index d22463dc..2c26f3b2 100644
+--- a/src/vpux_compiler/src/dialect/IE/transforms/passes/adapt_shapes_for_scale_shift.cpp
++++ b/src/vpux_compiler/src/dialect/IE/transforms/passes/adapt_shapes_for_scale_shift.cpp
+@@ -31,7 +31,7 @@ namespace {
+ template <typename EltwiseOp>
+ class BroadcastEltwiseRewriter final : public mlir::OpRewritePattern<EltwiseOp> {
+ public:
+-    BroadcastEltwiseRewriter<EltwiseOp>(mlir::MLIRContext* ctx, Logger log)
++    BroadcastEltwiseRewriter(mlir::MLIRContext* ctx, Logger log)
+             : mlir::OpRewritePattern<EltwiseOp>(ctx), _log(log) {
+         this->setDebugName("BroadcastEltwiseRewriter");
+     }
+@@ -198,7 +198,7 @@ bool isLegalEltwise(mlir::Operation* op) {
+ template <typename EltwiseOp>
+ class TransposeEltwiseRewriter final : public mlir::OpRewritePattern<EltwiseOp> {
+ public:
+-    TransposeEltwiseRewriter<EltwiseOp>(mlir::MLIRContext* ctx, Logger log)
++    TransposeEltwiseRewriter(mlir::MLIRContext* ctx, Logger log)
+             : mlir::OpRewritePattern<EltwiseOp>(ctx), _log(log) {
+         this->setDebugName("TransposeEltwiseRewriter");
+     }
+@@ -304,7 +304,7 @@ bool isPotentialScaleShift(mlir::Operation* op) {
+ template <typename EltwiseOp>
+ class MultiNonTrivialDimEltwiseRewriter final : public mlir::OpRewritePattern<EltwiseOp> {
+ public:
+-    MultiNonTrivialDimEltwiseRewriter<EltwiseOp>(mlir::MLIRContext* ctx, Logger log)
++    MultiNonTrivialDimEltwiseRewriter(mlir::MLIRContext* ctx, Logger log)
+             : mlir::OpRewritePattern<EltwiseOp>(ctx), _log(log) {
+         this->setDebugName("MultiNonTrivialDimEltwiseRewriter");
+     }
+diff --git a/src/vpux_compiler/src/dialect/IE/transforms/passes/convert_to_scale_shift.cpp b/src/vpux_compiler/src/dialect/IE/transforms/passes/convert_to_scale_shift.cpp
+index 82ca5417..705cff12 100644
+--- a/src/vpux_compiler/src/dialect/IE/transforms/passes/convert_to_scale_shift.cpp
++++ b/src/vpux_compiler/src/dialect/IE/transforms/passes/convert_to_scale_shift.cpp
+@@ -196,7 +196,7 @@ mlir::LogicalResult verifyAndBroadcastInput(mlir::Location loc, mlir::Value& inp
+ template <typename BiasTypeOp>
+ class ConvertBiasToScaleShift final : public mlir::OpRewritePattern<BiasTypeOp> {
+ public:
+-    ConvertBiasToScaleShift<BiasTypeOp>(mlir::MLIRContext* ctx, mlir::PatternBenefit benefit, Logger log)
++    ConvertBiasToScaleShift(mlir::MLIRContext* ctx, mlir::PatternBenefit benefit, Logger log)
+             : mlir::OpRewritePattern<BiasTypeOp>(ctx, benefit), _log(log) {
+         this->setDebugName("ConvertBiasToScaleShift");
+     }
+diff --git a/src/vpux_compiler/src/dialect/VPU/utils/nce_sparsity.cpp b/src/vpux_compiler/src/dialect/VPU/utils/nce_sparsity.cpp
+index ebaeb418..4e9a67b5 100644
+--- a/src/vpux_compiler/src/dialect/VPU/utils/nce_sparsity.cpp
++++ b/src/vpux_compiler/src/dialect/VPU/utils/nce_sparsity.cpp
+@@ -344,7 +344,8 @@ bool vpux::VPU::NCESparsity::isSparsifiableWeightsOperand(mlir::Value operand) {
+     if (!sourceOp) {
+         return false;
+     }
+-    for (const auto transformation : sourceOp.getContentAttr().getTransformations()) {
++    auto itervalue = sourceOp.getContentAttr().getTransformations();
++    for (const auto transformation : itervalue) {
+         if (mlir::isa<vpux::Const::SparsifyAttr, vpux::Const::GetSparsityMapAttr>(transformation)) {
+             VPUX_THROW("Trying to sparsify already sparsity related content at '{0}'", sourceOp->getLoc());
+         }
+diff --git a/src/vpux_compiler/src/dialect/VPUIP/IR/ops/sw_kernel.cpp b/src/vpux_compiler/src/dialect/VPUIP/IR/ops/sw_kernel.cpp
+index eec48216..ad7a00ef 100644
+--- a/src/vpux_compiler/src/dialect/VPUIP/IR/ops/sw_kernel.cpp
++++ b/src/vpux_compiler/src/dialect/VPUIP/IR/ops/sw_kernel.cpp
+@@ -560,7 +560,8 @@ mlir::LogicalResult SwKernelOp::verify() {
+                                "SW Kernel dynamicInputShapes size doesn't match with number of positive elements in "
+                                "dynamicInputShapesMap");
+             }
+-            for (const auto& i : getDynamicInputShapesMap().value_or(llvm::ArrayRef<int32_t>())) {
++	    auto itervalue = getDynamicInputShapesMap().value_or(llvm::ArrayRef<int32_t>());
++	    for (const auto& i : itervalue) {
+                 if (i >= checked_cast<std::remove_reference<decltype(i)>::type>(getDynamicInputShapes().size())) {
+                     return errorAt(
+                             op, "SW Kernel dynamicInputShapesMap contains values which are out of dynamicInputShapes "
+@@ -595,7 +596,8 @@ mlir::LogicalResult SwKernelOp::verify() {
+                                "SW Kernel dynamicOutputShapes size doesn't match with number of positive elements in "
+                                "dynamicOutputShapesMap");
+             }
+-            for (const auto& i : getDynamicOutputShapesMap().value_or(llvm::ArrayRef<int32_t>())) {
++	    auto itervalue = getDynamicOutputShapesMap().value_or(llvm::ArrayRef<int32_t>());
++            for (const auto& i : itervalue) {
+                 if (i >= checked_cast<std::remove_reference<decltype(i)>::type>(getDynamicOutputShapeBuffs().size())) {
+                     return errorAt(
+                             op, "SW Kernel dynamicOutputShapesMap contains values which are out of dynamicOutputShapes "
+diff --git a/src/vpux_compiler/src/dialect/VPUIP/IR/types/iti_buffer.cpp b/src/vpux_compiler/src/dialect/VPUIP/IR/types/iti_buffer.cpp
+index ebb7cb25..9a769cf4 100644
+--- a/src/vpux_compiler/src/dialect/VPUIP/IR/types/iti_buffer.cpp
++++ b/src/vpux_compiler/src/dialect/VPUIP/IR/types/iti_buffer.cpp
+@@ -309,7 +309,8 @@ mlir::LogicalResult VPUIP::ITIBufferType::verify(FuncRef<mlir::InFlightDiagnosti
+             return result;
+         }
+ 
+-        for (const auto& inHalo : outHalo.getInwardHaloRegions().getValue()) {
++	auto itervalue = outHalo.getInwardHaloRegions().getValue();
++	for (const auto& inHalo : itervalue) {
+             const auto inHaloAttr = mlir::cast<vpux::VPUIP::HaloRegionAttr>(inHalo);
+             const auto inHaloShape = parseIntArrayAttr<int64_t>(inHaloAttr.getShape());
+ 
+diff --git a/src/vpux_compiler/src/dialect/VPUIP/utils/sw_utils.cpp b/src/vpux_compiler/src/dialect/VPUIP/utils/sw_utils.cpp
+index 33b83594..e30f77e5 100644
+--- a/src/vpux_compiler/src/dialect/VPUIP/utils/sw_utils.cpp
++++ b/src/vpux_compiler/src/dialect/VPUIP/utils/sw_utils.cpp
+@@ -1307,6 +1307,7 @@ InputTiling backInferMvn1SumSwKernelInputTile(VPUIP::SwKernelOp swKernelOp, cons
+     auto baseSize = static_cast<int64_t>(inH / outH);
+ 
+     SmallVector<int64_t> splitInShape(outH, baseSize);
++    splitInShape[0] = 0;
+ 
+     // keep first shave indices equal for correct unroll cmx input buffer offsets
+     // Distribute on first shave if largeNumb is greater than outH / 2
+@@ -1324,6 +1325,8 @@ InputTiling backInferMvn1SumSwKernelInputTile(VPUIP::SwKernelOp swKernelOp, cons
+ 
+     SmallVector<int64_t> splitInOffset(outH);
+     splitInOffset[0] = 0;
++    // Derefernecing the input iterator is giving a potentially unitialized value...
++    // error: ‘*(long int*)((char*)&splitInShape + offsetof(llvm::SmallVector<long int, 6>,llvm::SmallVector<long int, 6>::<unnamed>.llvm::SmallVectorStorage<long int, 6>::InlineElts[0]))’ may be used uninitialized [-Werror=maybe-uninitialized]
+     std::partial_sum(splitInShape.begin(), splitInShape.end() - 1, splitInOffset.begin() + 1);
+ 
+     auto outTileShapeH = outputTile.shape[Dims4D::Act::H];
+diff --git a/src/vpux_compiler/src/dialect/const/passes/apply_swizzling.cpp b/src/vpux_compiler/src/dialect/const/passes/apply_swizzling.cpp
+index 33257967..a753ad48 100644
+--- a/src/vpux_compiler/src/dialect/const/passes/apply_swizzling.cpp
++++ b/src/vpux_compiler/src/dialect/const/passes/apply_swizzling.cpp
+@@ -38,7 +38,8 @@ void ApplySwizzlingPass::safeRunOnFunc() {
+             return;
+         }
+ 
+-        for (auto transf : constOp.getContentAttr().getTransformations()) {
++	auto itervalue = constOp.getContentAttr().getTransformations();
++	for (auto transf : itervalue) {
+             if (mlir::isa<Const::SwizzleConstantAttr>(transf)) {
+                 return;
+             }
+-- 
+2.50.0
+
diff --git a/compiler/patches/0001-HACK-Ignore-errors-with-GCC-15-on-Fedora-42.patch b/compiler/patches/0001-HACK-Ignore-errors-with-GCC-15-on-Fedora-42.patch
new file mode 100644
index 0000000..1f315d7
--- /dev/null
+++ b/compiler/patches/0001-HACK-Ignore-errors-with-GCC-15-on-Fedora-42.patch
@@ -0,0 +1,38 @@
+From 2e4504aaf9600d80836f22821a22fe9a74d070ff Mon Sep 17 00:00:00 2001
+From: "Alexander F. Lent" <lx@xanderlent.com>
+Date: Wed, 9 Jul 2025 21:41:16 -0400
+Subject: [PATCH] HACK: Ignore errors with GCC 15 on Fedora 42
+
+(For Intel's npu-nn-cost-model component.)
+---
+ include/vpu/utils.h | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/include/vpu/utils.h b/include/vpu/utils.h
+index 2bc4990..d892e8b 100644
+--- a/include/vpu/utils.h
++++ b/include/vpu/utils.h
+@@ -52,6 +52,10 @@ inline T dpu_schedule(const unsigned int n_procesors, const std::vector<T>& task
+     return result;
+ }
+ 
++#if defined(__GNUC__)
++#pragma GCC diagnostic push
++#pragma GCC diagnostic ignored "-Wfree-nonheap-object"
++#endif
+ template <>
+ inline CyclesInterfaceType dpu_schedule(const unsigned int n_procesors,
+                                         const std::vector<CyclesInterfaceType>& tasks_cost,
+@@ -75,6 +79,9 @@ inline CyclesInterfaceType dpu_schedule(const unsigned int n_procesors,
+     }
+     return result;
+ }
++#if defined(__GNUC__)
++#pragma GCC diagnostic pop
++#endif
+ 
+ /**
+  * @brief Multiply and accumulate an array
+-- 
+2.50.0
+
-- 
2.50.0

